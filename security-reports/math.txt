'npx hardhat clean' running (wd: C:\Users\JInfi\hoodcoin-contracts)
'npx hardhat clean --global' running (wd: C:\Users\JInfi\hoodcoin-contracts)
Problem deserializing hardhat configuration, using defaults: Expecting value: line 1 column 1 (char 0)
'npx hardhat compile --force' running (wd: C:\Users\JInfi\hoodcoin-contracts)

HoodCoinManager._migrateToUniswap(address) (contracts/HoodCoinManager.sol#733-815) uses timestamp for comparisons
	Dangerous comparisons:
	- remainingReservedTokens > 0 (contracts/HoodCoinManager.sol#790)
	- remainingEth > 0 (contracts/HoodCoinManager.sol#804)
	- require(bool,string)(sentCreator,Creator ETH transfer failed) (contracts/HoodCoinManager.sol#810)
	- require(bool,string)(sentTreasury,Treasury ETH transfer failed) (contracts/HoodCoinManager.sol#813)
HoodCoinManager.isUserVerifiedForHood(address,string) (contracts/HoodCoinManager.sol#850-858) uses timestamp for comparisons
	Dangerous comparisons:
	- keccak256(bytes)(abi.encodePacked(location.neighborhood)) == keccak256(bytes)(abi.encodePacked(neighborhood)) (contracts/HoodCoinManager.sol#855-857)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#block-timestamp

Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#144-223) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#190)
	- inverse = (3 * denominator) ^ 2 (node_modules/@openzeppelin/contracts/utils/math/Math.sol#205)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#144-223) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#190)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#209)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#144-223) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#190)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#210)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#144-223) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#190)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#211)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#144-223) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#190)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#212)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#144-223) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#190)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#213)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#144-223) performs a multiplication on the result of a division:
	- denominator = denominator / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#190)
	- inverse *= 2 - denominator * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#214)
Math.mulDiv(uint256,uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#144-223) performs a multiplication on the result of a division:
	- prod0 = prod0 / twos (node_modules/@openzeppelin/contracts/utils/math/Math.sol#193)
	- result = prod0 * inverse (node_modules/@openzeppelin/contracts/utils/math/Math.sol#220)
Math.invMod(uint256,uint256) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#243-289) performs a multiplication on the result of a division:
	- quotient = gcd / remainder (node_modules/@openzeppelin/contracts/utils/math/Math.sol#265)
	- (gcd,remainder) = (remainder,gcd - remainder * quotient) (node_modules/@openzeppelin/contracts/utils/math/Math.sol#267-274)
HoodCoinManager.calculateTokensForEth(address,uint256) (contracts/HoodCoinManager.sol#488-547) performs a multiplication on the result of a division:
	- ethWithoutRoyalty = (ethAmount * 10000) / (10000 + MINT_ROYALTY) (contracts/HoodCoinManager.sol#502-503)
	- reserveLeft = ethWithoutRoyalty (contracts/HoodCoinManager.sol#510)
	- tokensAtStep = (reserveLeft * multiFactor) / step.price (contracts/HoodCoinManager.sol#540)
HoodCoinManager._migrateToUniswap(address) (contracts/HoodCoinManager.sol#733-815) performs a multiplication on the result of a division:
	- tokensForLiquidity = (ethForLiquidity * 1e18) / currentPrice (contracts/HoodCoinManager.sol#750)
	- (tokenAmount,ethAmount,None) = router.addLiquidityETH{value: ethForLiquidity}(token,tokensForLiquidity,(tokensForLiquidity * 95) / 100,(ethForLiquidity * 95) / 100,address(0),block.timestamp + 600) (contracts/HoodCoinManager.sol#772-781)
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#divide-before-multiply

ERC20Initializable._name (contracts/lib/ERC20Initializable.sol#21) should be constant 
ERC20Initializable._symbol (contracts/lib/ERC20Initializable.sol#22) should be constant 
Reference: https://github.com/crytic/slither/wiki/Detector-Documentation#state-variables-that-could-be-declared-constant
. analyzed (20 contracts with 3 detectors), 15 result(s) found
